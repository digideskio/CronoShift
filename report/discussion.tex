\section{Dicussion}

\subsection{Evolution}
The original pitch started as ``Mix the time-jump feature from
Chronotron, with the Shift feature from shift''.  The game ended up as
something more like ``Take the time-jump feature from Chronotron and
add some Sokoban crates''.  In this section we will describe how and why
we changed the pitch over time.\\


When we started, we looked at doing mixing Chronotron and Shift.  To
keep things simple, we decided to reduce the game to a turn-based
variant (both Chronotron and Shift are real-time games).

Using a grid world as basis, we could fairly trivially reason about
the time machine mechanics.  During the initial design, we realised
that without some manipulatable obstacles the time machine would be
redundant.  We created the ``gate'' and the ``pressure plate'' for
this purpose.

But we could never really agree on how to the ``Shift'' feature should
work.  After a few weeks we ended up shelving it as we felt it was
just getting in our way.  We decided to add the pushable crates from
Sokoban as a replacement.

It was very hard to use crates in the level design.  In Sokoban,
crates have to end at specific nodes (``goal locations'').  But in
JikiBan, they do not directly have a use to the player.  Due to rules
behind how to push crates, the player could usually just walk around
the crate.  Also, with a time-machine the player can always create a
time-clone to replace the crate.

We thought about doing a pressure plate that could only be triggered
by a crate.  However, implementing that field, we deviced a way to use
crates to create a ``one-way'' path in the game.  This also lead to
the ``suicide''-construction.

After a while, the ``one-way'' emulation got annoying to write and we
implemented an actual ``one-time pressure plate''.  We also added the
``one-time passage'' to compliment it.


\subsection{If we could do it all over \ldots}
The first thing would have been not wasting any time with Unity.
While Unity is (probably) a reasonable prototype framework for
real-time position-based games, it felt very cumbersome for turn-based
and node-based games.

Secondly, we would seriously consider designing the game with a level
editor in mind from the start.  Originally levels were written by
``hand'' in a regular text editor.  For anything but the smallest
levels it gets very difficult to envision the level and also counting
the offset gets tedious very quickly.

Make it easier to getting the solutions from players.  Thor reported
that some of our play testers did some ``interesting solutions'', but
unfortunately we were unable to get the recorded solutions.  While we
could reason about the efficiency of the solution being inferior to
ours, seeing how the player solved the level might have proven useful
to us.

